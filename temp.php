
Представь, что тебя приняли на работу в отдел по борьбе с инопрланетной преступностью
и направили для стажировки в тиюрьму, в отдаленный уголок вселенной, в качестве ИТ специалиста.


Прибыв в пункт назначения ты увидел кипы бумаг с информацией о преступниках. Твоя задача
Привести все в божеский вид и оцифровать все эти архивы. Единственный инструменр php&
Ну что, приступим?!


Первое что нам нужно сделать, это создать абстрактный класс, описывающий общие элементы для всех преступников.
Делается это с помощью специального слова abstract:

<?php
abstract class Alien
{

}
?>

У тебя может возникнуть вопрос, почему абстрактный класс, и что это такое...
Абстрактный класс, это класс, объекты которого нельзя создать. Это как бы шаблон, для дургих, дочерних классов.
Зачем его использовать? Например для уменьшения кода, а значит и нашей работы! Вот смотри, в нашей тюрьме могут
содержаться разные существа, но мы знаем, что у них у всех есть Имя, Какое-то количество конечностей, глаз, разный цвет кожи.

Конечно, мы можем избежать абстрактные классы, но тогда нам понадобится для каждого класса прописывать эти данные и методы,
работающие с ними, что очень увеличит объем и ухудшит читабельность кода. Давай в наш Абстрактный класс добавим общие
характеристики. делается это через спечиальное слово public (так указывается область видимости) и имя характеристики:

<?php
abstract class Alien
{
    const PRISON = "Межгалактическая тюрьма третьего Солнца";
    public static $count = 0;
    public $name;
    public $limbNum;
    public $eyeNum;
    public $skinColor;
}
?>

Ты можешь заметить, что мы добавили в класс 2 необычные переменные: PRISON - это константа, переменная которую
нельзя изменить. Сюда мы поместили название нашей тюрьмы. Так же мы добавили переменную $count, в которой хранится общее
количество заключенных и с помощью которой мы сможем присваивать номер вновь прибывшим. Мы сделали эту переменную
статической, что бы мы могли обращаться к ней без создания элемента класса, для чего добавили слово static.


Помнишь, я говорил, что в абстрактном классе будут общие элементы дочерних классов? А что же с различиями? Для них мы
создадим отдельные классы. Например, для Марсиан. Ты вкурсе, что марсиане обожают земных рабов? Так что, приступим:

<?php
class Martian extends Alien
{
    public $slaveEarthman;
    private $number;
}
?>

Мы создали класс, у которого есть свойства $slaveEarthman - количество рабов данного марсианина, и $number - порядковый
номер нашего заключенного. мы сделали его приватным, так что только наш класс Марсианин будет иметь к нему доступ.



Вроде бы мы разобрались со свойствами нашего класса, но теперь нам нужны методы, которые позволят нам взаимодействовать
с этими свойствами. Начнем мы, конечно, с конструктора. Это специальный, магический метод класса, который автоматически
применяется при создании нового объекта класса.
<?php
abstract class Alien
{
    const PRISON = "Межгалактическая тюрьма третьего Солнца";
    public static $count = 0;
    public $name;
    public $limbNum;
    public $eyeNum;
    public $skinColor;

    public function __construct($name, $limbNum, $eyeNum, $skinColor)
    {
        $this->name = $name;
        $this->skinColor = $skinColor;
        $this->eyeNum = $eyeNum;
        $this->limbNum = $limbNum;
        self::$count++;
    }
}
?>

Добавим методы для взаимодействия с свойствами:

<?php
abstract class Alien
{
    const PRISON = "Межгалактическая тюрьма третьего Солнца";
    public static $count = 0;
    public $name;
    public $limbNum;
    public $eyeNum;
    public $skinColor;

    public function __construct($name, $limbNum, $eyeNum, $skinColor)
    {
        $this->name = $name;
        $this->skinColor = $skinColor;
        $this->eyeNum = $eyeNum;
        $this->limbNum = $limbNum;
        self::$count++;
    }

    public function getName()
    {
        return $this->name;
    }
    public function getLimbNum()
    {
        return $this->limbNum;
    }
    public function getEyeNum()
    {
        return $this->eyeNum;
    }
    public function getSkinColor()
    {
        return $this->skinColor;
    }
    public function getPtison()
    {
        return self::PRISON;
    }
    public function getCount()
    {
        return self::$count;
    }
}
?>

Тут все просто.  Конструктор получает набор аргументов. C помошью $this мы присваивает их свойствам конкретного объекта.
стоит обратить внимание на строчку:
<?php
    self::$count++;
?>

Дело в том, что $count у нас статическая переменная, и $self позволяет нам получить к ней доступ.

Дальше идут функции, возвращяющие нам необходимый элемент, например

<?php
    public function getName()
    {
        return $this->name;
    }
?>

вернет имя нашего пришельца. делается это с помощьью специального слова return. Обрати внимание, здесь тоже искользуется
$this, что позволяет вернуть заначение нужного свойства, конкретного объекта. Например у нас есть Зорг и Барталамей.
Именно с помощью $this (контекста вызова) будет понятно чье имя нам нужно.





Но, ведь нельзя создать объект абстрактного класса, скажешь ты! Правильно! Поэтому мы создадим конструктор у нашего
класса Марсианин, который будет использовать родительский конструктор и расшириет его действиями, необходимыми для
конктретного класса, а так же добавим специфические методы для Марсианина:

<?php

class Martian extends Alien
{
    public $slaveEarthman;
    private $number;

    public function __construct($name, $limbNum, $eyeNum, $skinColor, $slaveEarthman)
    {
        parent::__construct($name, $limbNum, $eyeNum, $skinColor);
        $this->slaveEarthman = $slaveEarthman;
        $this->number = $this->getCount();
    }

    public function getSlaves()
    {
        return $this->slaveEarthman;
    }

    public function __toString()
    {
        return "Заключенный № " . $this->number . ", кличка " . $this->getName() . " основные данные: <br> количество глаз:" . $this->getEyeNum() .
            "<br> количество конечностей: " . $this->getLimbNum() . "<br>Цвет кожи: " .$this->getSkinColor() .
            "<br>Известное кол-во рабов: " . $this->getSlaves() . "<br>Место заключения:<br>" ;
    }
}
?>

Обрати внимание, в кончтрукторе есть строчка:
<?php
    parent::__construct($name, $limbNum, $eyeNum, $skinColor);
?>
Именно благодаря ей мы, при создании Марсианина, используем конструктор родительского элемента.  С помощью метода родительского
класса getCount() получим количесво заключенных, к которому уже прибавится наш новенький марсианин (помнишь, мы увеличиваем
$count в родительском конструкторе.)


Обрати особое внимание на:


<?php
    public function __toString()
    {
        return "Заключенный № " . $this->number . ", кличка " . $this->getName() . " основные данные: <br> количество глаз:" . $this->getEyeNum() .
            "<br> количество конечностей: " . $this->getLimbNum() . "<br>Цвет кожи: " .$this->getSkinColor() .
            "<br>Известное кол-во рабов: " . $this->getSlaves() . "<br>Место заключения:" . Alien::PRISON . "<br><br>";
    }
?>

это еще одим магический метод, возвращаюший объект нашего класса в подходящем для вывода на экран виде, и именно в виде
строки. И да, молодец, что заметил: все магические методы начинаются с 2 подчеркиваний.


Что же наши классы готовы, и мы можем начать вносить в систему Марсиан, содержащихся в нашей тюрьме. Для этого с помошью
сова new создадим наши объекты:

<?php
    $prison1 = new Martian('Закария', 3, 2, 'красный', 10);
    $prison2 = new Martian('Грог', 10, 1, 'зеленый', 110);
?>

Да, все верно, в скобках мы указываем свойство наших марсиан! Помнишь, мы создали магический метод __toString?
так вот, если бы его не было, то нам бы пришлось прописывать:

<?php
echo "Заключенный " . $prison1->getName() . " основные данные: <br> количество глаз:" . $prison1->getEyeNum() .
    "<br> количество конечностей: " . $prison1->getLimbNum() . "<br>Цвет кожи: " .$prison1->getSkinColor() .
    "<br>Известное кол-во рабов: " . $prison1->getSlaves() . "<br><br>";
?>

каждый раз, когда мы бы хотели вывести на экран информацию о нашем заключенном.
Теперь же, нам достаточно просто написать:
<?php
    echo $prison2;
?>



Как видешь результат одинаковый, но магический метод сильно упростит нам жизнь)
Ах да, чуть не забыл!! Помнишь, я говорил, что доступ к статической переменной можно получить без объекта класса? Вот
как это работает:

<?php
    echo Alien::$count . "<br>";
?>

Ну что, надеюсь ты все понял и справишься дальше сам, начни с венерианцев, они такие милахи, все пытаются захватить мир...











